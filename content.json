{"meta":{"title":"桀士","subtitle":"『桀士』","description":"看天空的女孩是寂寞的，看天空的男孩是找UFO！","author":"Jackie Tang(唐浩桀)","url":"https://tanghaojie.github.io","root":"/"},"pages":[{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-11T07:01:24.899Z","comments":true,"path":"contact/index.html","permalink":"https://tanghaojie.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-11T07:00:53.111Z","comments":true,"path":"about/index.html","permalink":"https://tanghaojie.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2019-10-11T06:59:13.783Z","comments":true,"path":"categories/index.html","permalink":"https://tanghaojie.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2019-10-11T07:00:25.097Z","comments":true,"path":"tags/index.html","permalink":"https://tanghaojie.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-10-11T07:01:39.596Z","comments":true,"path":"friends/index.html","permalink":"https://tanghaojie.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"jenkins从github拉取nuxt项目部署到docker, windows平台","slug":"nuxt-docker","date":"2020-06-10T14:15:05.000Z","updated":"2020-06-10T10:25:44.760Z","comments":true,"path":"2020/06/10/nuxt-docker/","link":"","permalink":"https://tanghaojie.github.io/2020/06/10/nuxt-docker/","excerpt":"","text":"准备环境 开发环境：win10 服务器 docker 宿主环境：win10 docker 环境：linux jenkins 部署环境：docker 配置 jenkins 插件：github、git、publish over ssh。提前要在全局工具配置里面配置 git，系统配置里面配置 github server、publish over SSH。这常用工具网上都有教程，不单独说了。有一个坑是，publish over SSH 连接 OpenSSH for windows，我用 key 始终不行， 点下面高级，用户名密码模式搞定的。 服务器 win10：OpenSSH for windows这个需要在你的 win10 服务器上配置，网上很多，我也是照着网上做的。 docker：node 镜像我用的 node 官方镜像生产的自己的镜像，你可以用自己习惯的。把 node 容器运行起来，docker exec -it YourName /bin/bash进入容器，执行npm install -g cnpm --registry=https://registry.npm.taobao.org配置淘宝源，新建 /app文件夹，之后代码构建和发布就都放这里了。然后把这个容器打包成镜像，名字随便，就叫mynode:latest（仓库：版本）。 开始 jenkins：1.新建任务。2.勾选 github 项目：填写地址：git@github.com:YourName/YourProject.git。3.源码管理：选择 git，url 和上面一样，设置 Credentials，如果是 public 项目就不用设置。4.轮询 SCM 或者 GitHub hook 自己看着办。5.构建：选择执行 shell，命令写：tar -zcvf frontend.tar.gz *，意思是把所有代码打包到frontend.tar.gz。6.构建：选择 Send files or execute commands over SSH。6.1 SSH Server 选择之前配置好的。6.2 Source files：frontend.tar.gz。6.3 Remote directory：/（注意这个根目录是你之前配置好的 SSH Server 连接到的目录，比如你之前配置的/d:/docker/，那么这里就会把 frontend.tar.gz 上传到 d:/docker/frontend.tar.gz。windows SSH 连接 D 盘就是这么写的/D:/前面有个/）6.4 Exec command：frontend.bat。意思就是执行远端 windows 服务器上的frontend.bat文件，所以去远端服务器的C:\\Users\\Administrator下新建这个frontend.bat文件，Administrator 是你登录的用户名。连接默认就固定这个目录，我尝试了几个办法想把文件放 D 盘执行的，但一直不行，放弃了，frontend.bat里面写什么下面说。7.保存。 nuxt 项目：1.上传代码的时候忽略.nuxt node_modules 等等这些文件，没啥好说的。2.根目录添加Dockerfile。写入： FROM mynode:latest WORKDIR /app COPY . /app RUN cnpm install \\ &amp;&amp; npm run build EXPOSE 3000 CMD [\"npm\", \"run\", \"start\"]简单解释一下，用 mynode （上面准备工作弄好了的）构建新镜像，设置工作目录/app，把当前所有文件拷贝到/app，（在工作目录）执行cnpm install 和 npm run build， 对外访问端口 3000，容器开始运行后（在工作目录）执行npm run start。这里构建发布容器，设置依赖，运行就弄好了。之后就是去 windows 服务器上执行脚本，每次构建之前删除旧的，运行新的。 服务器脚本（frontend.bat）：直接上内容： d: # 切换到d盘 cd docker # 到d:/docker这个文件夹 rd /S /Q frontend # 删除d:/docker下，frontend这个文件夹 mkdir frontend # 新建 frontend 文件夹 tar -xvf frontend.tar.gz -C ./frontend # 解压jenkins打包上传过来的文件到frontend文件夹 cd frontend # 到d:/docker/frontend这个文件夹 docker stop frontend # 停止已运行容器 docker rm -v frontend # 删除已存在容器 docker image rm frontend # 删除镜像 docker build -t frontend:latest . # 运行Dockerfile打包生成新镜像：frontend:latest，注意最后有一个点，表示用当前目录下的Dockerfile来执行的 docker run -itd --restart=always --name frontend -p 3000:3000 frontend:latest # 运行容器到这里就全部完成了。去 jenkins 立即构建就 ok 了。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"git commit规范化，设置Commitizen，符合Angular的规范","slug":"git-commitizen","date":"2020-05-15T12:24:09.000Z","updated":"2020-05-15T06:48:05.769Z","comments":true,"path":"2020/05/15/git-commitizen/","link":"","permalink":"https://tanghaojie.github.io/2020/05/15/git-commitizen/","excerpt":"","text":"安装配置commitizen地址cz-conventional-changelo地址：规范要求，不同的适配器要求不同conventional-changelog地址：生成changelog.md npm install -g commitizen npm install -g cz-conventional-changelog npm install -g conventional-changelog-cli commitizen init cz-conventional-changelog --save-dev --save-exact如果已经有其他适配器了，会报错，用 --force 替换掉，即： commitizen init cz-conventional-changelog --save-dev --save-exact --force使用以后提交代码就用git cz -m替代git commit -m就好了，或者不输入message跟着提示走就没问题。type值： 值 描述 feat 新增一个功能 fix 修复一个Bug docs 文档变更 style 代码格式（不影响功能，例如空格、分号等格式修正） refactor 代码重构 perf 改善性能 test 测试 build 变更项目构建或外部依赖（例如scopes: webpack、gulp、npm等） ci 更改持续集成软件的配置文件和package中的scripts命令，例如scopes: Travis, Circle等 chore 变更构建流程或辅助工具 revert 代码回退 生成changelog：conventional-changelog -p angular -i CHANGELOG.md -s 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"docker速查表","slug":"docker-cheat-sheet","date":"2020-05-14T16:50:41.000Z","updated":"2020-05-15T07:16:10.286Z","comments":true,"path":"2020/05/15/docker-cheat-sheet/","link":"","permalink":"https://tanghaojie.github.io/2020/05/15/docker-cheat-sheet/","excerpt":"","text":"容器（Container）生命周期 docker create 创建容器但不启动它。 docker rename 用于重命名容器。 docker run 一键创建并同时启动该容器。 docker rm 删除容器。 docker update 调整容器的资源限制。 常用参数docker run --rm 临时容器，容器停止之后删除它。docker run -d container_id，-d 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）docker run -p container_id，-p 表示指定端口映射，格式：主机（宿主）端口:容器端口 启动和停止 docker start 启动已存在的容器。 docker stop 停止运行中的容器。 docker restart 重启容器。 docker pause 暂停运行中的容器，将其「冻结」在当前状态。 docker unpause 结束容器暂停状态。 docker wait 阻塞地等待某个运行中的容器直到停止。 docker kill 向运行中的容器发送 SIGKILL 指令。 docker attach 连接到运行中的容器。 信息 docker ps 查看运行中的所有容器。 docker logs 从容器中读取日志。（你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 json-file 和 journald）。 docker inspect 查看某个容器的所有信息（包括 IP 地址）。 docker events 从容器中获取事件 (events)。 docker port 查看容器的公开端口。 docker top 查看容器中活动进程。 docker stats 查看容器的资源使用量统计信息。 docker diff 查看容器文件系统中存在改动的文件。 常用参数docker ps -a 显示所有容器，包括运行中和已停止的。docker stats --all 同样将显示所有容器，默认仅显示运行中的容器。 导入 / 导出 docker cp 在容器和本地文件系统之间复制文件或目录。 docker export 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。 执行命令 docker exec 在容器内执行命令。 例如，进入正在运行的 foo 容器，并连接 (attach) 到一个新的 Shell 进程：docker exec -it foo /bin/bash。 镜像(Images)生命周期 docker images 查看所有镜像。 docker import 从归档文件创建镜像。 docker build 从 Dockerfile 创建镜像。 docker commit 为容器创建镜像，如果容器正在运行则会临时暂停。 docker rmi 删除镜像。 docker load 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。 docker save 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。 其它信息 docker history 查看镜像的历史记录。 docker tag 给镜像打标签命名（本地或者仓库均可）。 网络(Networks)生命周期 docker network create docker network rm 其它信息 docker network ls docker network inspect 建立连接 docker network connect docker network disconnect 仓库(Repository) docker login 登入仓管中心。 docker logout 登出仓管中心。 docker search 从仓管中心检索镜像。 docker pull 从仓管中心拉取镜像到本地。 docker push 从本地推送镜像到仓管中心。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"git速查表","slug":"git-cheat-sheet","date":"2020-05-14T08:20:07.000Z","updated":"2020-05-15T06:48:59.918Z","comments":true,"path":"2020/05/14/git-cheat-sheet/","link":"","permalink":"https://tanghaojie.github.io/2020/05/14/git-cheat-sheet/","excerpt":"","text":"git 从远程拉取代码、推代码的步骤 如果是几个人共同管理项目，并且你的队友在你之前推过代码，那你就需要 git pull 一下，把代码拉到本地，解决一下冲突，再执行以下步骤，将本地代码推到远程仓库。 git status #git仓库状态 git add * #更新的代码添加到暂存区 git commit -m “msg” #将暂存区的更新提交到仓库区 git pull #先git pull,拉取远程仓库所有分支更新并合并到本地 git push origin master #将本地分支的更新全部推送到远程仓库 git reset –mixed [哈希码] #回滚到这个哈希码，将本地归档区和缓冲区也进行回滚 git reset –hard [哈希码] #使用强制还原这个哈希码 git reset –soft [哈希码] #回滚到这个哈希码，只将本地归档区回滚 git revert [哈希码] #只是针对这个哈希码版本进行删除回滚操作 git log #查看日志 git reflog #查看操作记录，能找到之前的操作记录和哈希码 多分支开发 git branch -v #查看我们当前有哪些分支？ git branch [name] #创建name分支 git checkout [name] #切换到name分支 git checkout -b [name] #创建并切换到name分支 git merge [name] 将name分支合并到master分支 查看远端 git remove -v 添加多个远端 git remote set-url –add origin http://xxxxx/xxx/adsdsdsdcelery-demo.git 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"几何算法延伸","slug":"spatial-calculate-extend","date":"2020-05-10T07:10:26.000Z","updated":"2020-05-15T01:28:52.268Z","comments":true,"path":"2020/05/10/spatial-calculate-extend/","link":"","permalink":"https://tanghaojie.github.io/2020/05/10/spatial-calculate-extend/","excerpt":"","text":"线平行$$A_xB_y = A_yB_x$$ $$\\frac{A_x}{A_y} = \\frac{B_x}{B_y}$$ $$\\frac{A_x}{A_y} = \\frac{B_x}{B_y} = \\frac{B_z}{B_z}$$ 线垂直$$A_xB_x + A_yB_y = 0$$ $$A_xB_x + A_yB_y + A_zB_z = 0$$ 向量 $\\vec A$ $\\vec B$ 夹角方向（叉乘）$\\vec A$ $\\times$ $\\vec B$ &gt; 0 , $\\vec A$在$\\vec B$的顺时针方向。$\\vec A$ $\\times$ $\\vec B$ &lt; 0 , $\\vec A$在$\\vec B$的逆时针方向。$\\vec A$ $\\times$ $\\vec B$ = 0 , $\\vec A$ $\\vec B$共线。 判断凸多边形根据上面方向的性质，可以推论出来。以多边形相邻两条边为向量进行叉积和，如果全部大于零则是凸多边形，如果全部为零则共线，否则就是凹多边形。 计算任意多边形面积计算三角形面积根据上一篇几何基础，向量叉乘结果为带符号的平行四边形面积，那么三角形的面积为：$$Area = \\frac{\\vec {AB} \\times \\vec {AC}}{2}$$面积结果为带符号的值，正面积则ABC成左手系，负面积则ABC成右手系。 计算任意凹凸多边形面积计算多边形面积就是把多边形切分为多个三角形计算就好了。由于面积计算的结果是带符号的，因此，此结果对于凹凸多边形都是有效。甚至可以选取多边形外的一个点，来构建三角形计算，也是同样有效的，像这样：当然一般不会选择外部的点。 计算带孔多边形的面积当多边形存在“孔洞”时， 第一层孔洞的环序是与外环序一定是相反的，因此孔洞的面积和外环的面积结果也是相反的，直接相加即可。多层孔洞当然也是一样的道理。注意 环序是很重要的，同一层环进行面积计算的时候，要始终保持同一个方向的环序进行计算。 不同文件格式要求的最外部环序是不一样的，因此不要认为外环总是和大部分情况一样是逆时针的。 扩展1.ESRI shapefile：外层环序为顺时针。2.OGC规范：此标准未定义多边形旋转；实际的多边形旋转可以沿顺时针或逆时针方向进行。3.Oracle：Exterior ring boundaries must be oriented counterclockwise, and interior ring boundaries must be oriented clockwise.（外部环边界必须逆时针定向，而内部环边界必须顺时针定向。）4.SQL Server： If SQL Server finds outer rings oriented in a clockwise direction, it will re-orient such rings to counter-clockwise - the direction required for outer rings in the Geography data type. The same goes for inner rings (holes), which SQL Server will orient to clockwise.（如果SQL Server找到沿顺时针方向定向的外环，则它将重新定位此类环为逆时针方向-Geography数据类型中外环所需的方向。内环（孔）也是如此，SQL Server会将其定位为顺时针方向。）5.PostGIS：Forces the orientation of the vertices in a polygon to follow a Right-Hand-Rule, in which the area that is bounded by the polygon is to the right of the boundary. In particular, the exterior ring is orientated in a clockwise direction and the interior rings in a counter-clockwise direction.（强制多边形中顶点的方向遵循“右手规则”，其中多边形所包围的区域在边界的右边。特别地，外环沿顺时针方向定向，而内环沿逆时针方向定向。） 判断多边形的环序面积法多边形面积为正：逆时针；面积为负：顺时针； 凸多边形任取一点叉乘：$$\\vec {AB} \\times \\vec{BC}$$值为正：逆时针；值为负：顺时针。 极点法选择多边形上的某个极点（x最大、x最小、y最大、y最小），这个极点则一定在凸包上，计算叉积得到环序方向，和上面凸多边形算法结论一致。 计算多边形质心三角形三角形 $\\triangle ABC$ 质心计算公式：$$Centroid_x = \\frac{A_x + B_x + C_x}{3}$$$$Centroid_y = \\frac{A_y + B_y + C_y}{3}$$ 任意多边形任意平面多边形，若能被拆分为 $i$个简单图形，每个简单图形的质心为：$C_i$，面积为：$A_i$。则质心Centroid的坐标$(Centroid_x, Centroid_y)$，满足以下公式：$$Centroid_x = \\frac{\\sum {C_i}_x A_i}{\\sum A_i}$$$$Centroid_y = \\frac{\\sum {C_i}_y A_i}{\\sum A_i}$$ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"几何计算","slug":"几何计算","permalink":"https://tanghaojie.github.io/categories/几何计算/"}],"tags":[{"name":"几何计算","slug":"几何计算","permalink":"https://tanghaojie.github.io/tags/几何计算/"}],"author":null},{"title":"几何算法基础","slug":"spatial-calculate-basic","date":"2020-05-10T04:24:04.000Z","updated":"2020-05-15T01:28:52.267Z","comments":true,"path":"2020/05/10/spatial-calculate-basic/","link":"","permalink":"https://tanghaojie.github.io/2020/05/10/spatial-calculate-basic/","excerpt":"","text":"加$$\\vec A + \\vec B = (A_x + B_x, A_y + B_y, A_z + B_z)$$ 减$$\\vec A - \\vec B = (A_x - B_x, A_y - B_y, A_z - B_z)$$ 模$$\\left| \\vec A \\right| = \\sqrt[]{ A_x^2 + A_y^2 + A_z^2 }$$ 数乘（伸缩，换向）$$k \\vec A = (kA_x, kA_y, kA_z)$$ 点乘$$\\vec A \\cdot \\vec B = \\sum A_i B_i = A_xB_x + A_yB_y + A_zB_z$$ $$\\vec A \\cdot \\vec B = \\left| \\vec A \\right| \\left| \\vec B \\right| \\cos \\theta$$ 结果是一个标量（数）几何意义：1.降维，2.$\\vec B$在$\\vec A$上的投影 $$\\left| \\vec B \\right| \\cos \\theta$$ 点乘延伸：$$\\left| \\vec A \\cdot \\vec B \\right| \\le \\left| \\vec A \\right| \\left| \\vec B \\right|$$等号只在$\\vec A$与$\\vec B$共线时成立. $$\\vec A \\cdot \\vec B = \\vec B \\cdot \\vec A$$ $\\vec A \\cdot \\vec B &gt; 0$，夹角在 $0^\\circ$ 到 $90^\\circ$ 之间$\\vec A \\cdot \\vec B = 0$，垂直$\\vec A \\cdot \\vec B &lt; 0$，夹角在 $90^\\circ$ 到 $180^\\circ$ 之间 叉乘$$\\vec A \\times \\vec B = \\left| \\vec A \\right| \\left| \\vec B \\right| \\sin \\theta$$ 二维：$$\\vec A \\times \\vec B = A_xB_y - B_xA_y$$ 三维：$$\\vec A \\times \\vec B = A_yB_z- B_yA_z + A_zB_x - A_xB_z+ A_xB_y - A_yB_x$$ 几何意义：二维：$(0,0) \\quad (A_x, A_y) \\quad (B_x, B_y) \\quad ((A+B)_x, (A+B)_y)$构成的平行四边形带符号的面积三维：$\\vec A \\times \\vec B$ 结果的向量，垂直于 $\\vec A$ 和 $\\vec B$ 构成的平面 叉乘延伸：$$\\left| \\vec A \\times \\vec B \\right| = \\left| \\vec A \\right| \\left| \\vec B \\right| \\sin \\theta$$ $$\\vec A \\times \\vec B = - \\vec B \\times \\vec A$$ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"几何计算","slug":"几何计算","permalink":"https://tanghaojie.github.io/categories/几何计算/"}],"tags":[{"name":"几何计算","slug":"几何计算","permalink":"https://tanghaojie.github.io/tags/几何计算/"}],"author":null},{"title":"Hexo添加数学公式支持","slug":"hexo-LaTex","date":"2020-05-10T03:50:01.000Z","updated":"2020-05-14T03:27:23.107Z","comments":true,"path":"2020/05/10/hexo-LaTex/","link":"","permalink":"https://tanghaojie.github.io/2020/05/10/hexo-LaTex/","excerpt":"","text":"为后面的文档做准备，添加数学公式的支持。网上一堆更新渲染插件的办法，我都准备用了。幸好先看完了文章，后面要改node_modules里面的源码，这怎么可能！我不能把node_modules上传到github吧，不上传又怎么同步呢。后来看了一下，hexo-theme-matery做好了插件，那就简单了：themes/hexo-theme-matery/_config.yml中： mathjax: enable: true 完工～就是这么简单，然后每篇要用到公式的文档，头上修改mathjax: true就好了。 示例$\\cos$ $x_i^2$ $|x+y|$ $\\sqrt[3]{x+y}$ $\\int_{r=1}^\\infty$ $\\frac{\\partial x}{\\partial y}$ $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,.$$ $\\alpha$ $\\beta$ $\\theta$ $\\sum_{r=1}^n$ $\\prod_{i=1}^{K}$ $$\\begin{bmatrix} a &amp; b &amp; c &amp; d &amp; e\\\\ f &amp; g &amp; h &amp; i &amp; j \\\\ k &amp; l &amp; m &amp; n &amp; o \\\\ p &amp; q &amp; r &amp; s &amp; t \\end{bmatrix}$$ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"全国甲乙丙级测绘资质单位名单","slug":"surveying-qualification","date":"2020-05-09T15:01:28.000Z","updated":"2020-05-15T01:28:52.266Z","comments":true,"path":"2020/05/09/surveying-qualification/","link":"","permalink":"https://tanghaojie.github.io/2020/05/09/surveying-qualification/","excerpt":"","text":"全国甲乙丙级测绘资质单位名单：甲级：1326个 乙级：5081个 丙级：8790个 点击查看和下载 详细信息压缩包解压密码：关注公众号[桀士]，回复“资质”获取密码。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"author":null},{"title":"Scrapy爬虫使用","slug":"scrapy-tutorial","date":"2020-05-09T13:20:01.000Z","updated":"2020-05-09T09:53:12.508Z","comments":true,"path":"2020/05/09/scrapy-tutorial/","link":"","permalink":"https://tanghaojie.github.io/2020/05/09/scrapy-tutorial/","excerpt":"","text":"飞速起步 安装scrapypip install Scrapy（类unix记得加 sudo）安装完成以后，到命令行输入Scrapy，查看是否安装成功。 准备和配置 scrapy startproject [name]创建项目。 项目文件说明 items.py：数据模型，类似于dto、orm中的modelspiders：爬虫程序middlewares.py：模型中的中间件pipelines.py：管道，对item进行处理，类似于很多服务器的请求管道settings.py：程序设置,主要是一些优先级设置,优先级越高,值越小scrapy.cfg：配置 基础设置settings.py中，找到ROBOTSTXT_OBEY = True，改为ROBOTSTXT_OBEY = False或者把他注释了这东西的意思是：每个网站可以在根目录下放一个robots.txt的文件，文件里面告诉了爬虫哪些网址是可以爬的，当然这就是个君子协议，靠你自己选择是不是要遵守。 设置UTF-8：settings.py中，添加一行：FEED_EXPORT_ENCODING = 'utf-8' 生成爬虫命令行输入：scrapy genspider [文件名] [网址]，生成爬虫文件。可以在spiders文件夹下面看到。 开始代码 item：自己写一个item class yourItem(scrapy.Item): info1 = scrapy.Field() info2 = scrapy.Field() info1、info2，就是数据模型对应的字段，看scrapy.Item的源码，实际上就是个dict所以可以这样理解： { info1: None, info2: None } spider from name.items import yourItem class YourSpider(scrapy.Spider): name = 'yourname' allowed_domains = ['xxx.com'] start_urls = ['http://xxx.com/yyy/zzz'] def parse(self, response): info1 = response.xpath('//div/a/text()').extract_first() #第一个 info2 = response.xpath('//div/a/text()').extract() #extract 永远返回一个数组 item = yourItem() item['info1'] = info1 item['info2'] = info2 yield item 没啥好说的，就是爬取信息，然后设置item的属性就好。 可以爬了！！命令行输入：scrapy crawl yourname -o filename.csv，yourname 对应 YourSpider 这个类的name变量值。就会爬取数据放到 filename.csv 中，还有其他格式，自己研究。 pipelines如果你不想用scrapy默认的保存文件方法，那么就自定义一个保存文件的管道： class YourPipeline(object): def process_item(self, item, spider): # 伪代码 # open file # file.write(item.info1) # file.write(item.info2) # save and close file return item 之后到settings.py，输入： ITEM_PIPELINES = { 'name.pipelines.YourPipeline': 300, }启动当前管道配置优先级，数字越小，优先级越靠前，然后就只需要输入scrapy crawl yourname就可以运行和保存了 调试我用万能vscode：新建调试配置文件，输入 { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Scrapy\", \"type\": \"python\", \"request\": \"launch\", \"module\": \"scrapy\", \"args\": [ \"crawl\", \"yourname\" ] } ] } 搞定！ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"scrapy","slug":"scrapy","permalink":"https://tanghaojie.github.io/categories/scrapy/"},{"name":"python","slug":"scrapy/python","permalink":"https://tanghaojie.github.io/categories/scrapy/python/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://tanghaojie.github.io/tags/scrapy/"},{"name":"python","slug":"python","permalink":"https://tanghaojie.github.io/tags/python/"}],"author":null},{"title":"QGIS plugin开发使用","slug":"qgis-plugin","date":"2020-04-12T02:17:00.000Z","updated":"2020-04-13T06:12:46.155Z","comments":true,"path":"2020/04/12/qgis-plugin/","link":"","permalink":"https://tanghaojie.github.io/2020/04/12/qgis-plugin/","excerpt":"","text":"起步1.刚来就不建议看文档手动创建plugin了，python很熟悉的人可以看文档试试，否则还是别手动创建了，几乎所有的开发者都是通过Plugin Builder这个Plugin来创建的Plugin，安装好了以后，打开Plugin Builder，根据提示输入内容，一直下一步就创建好了。2.用 pyrcc5 -o resources.py resources.qrc命令，把resources.qrc资源文件转换成py文件，主程序test.py文件中已经自动引入了。如果没有pyrcc5命令，执行pip install PyQt5安装PyQt。3.把整个生成的文件夹，拷贝到，~\\AppData\\Roaming\\QGIS\\QGIS3\\profiles\\default\\python\\plugins 下面，所有的plugin其实都在这里。4.打开qgis插件–已安装，勾选test插件，就可以看到菜单上多了按钮，点击就能打开了。 以上最原始的demo就能够看见了，下面说说怎么自己写代码5.插件有一个test_dialog.py文件，里面最关键的一句代码应该是FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'Test_dialog_base.ui'))，这就是加载转换.ui文件给pyqt用的。6.生成的插件文件，包含了Test_dialog_base.ui，就是界面文件。安装QGIS的时候自带了Qt Designer，用Designer就可以打开就能看到和编辑了，这里从左边拖一个Push Button进去，后面用。编辑完成界面，去QGIS里面，取消勾选，在重新选中，就重新加载插件了，能够看出来结果。这里推荐一个插件 Plugin Reloader，不用每次去取消重勾选，它可以帮我们重加载插件。7.点击事件，在.ui文件对应的.py文件的构造函数，__init__中，加上self.pushButton.clicked.connect(self.pushButtonClicked)，文件头导入from PyQt5.QtWidgets import QMessageBox然后定义方法： def pushButtonClicked(self): QMessageBox.warning(None, 'info', '测试') 8.去QGIS里面reload插件，点击按钮就能看到结果了。9.更多的东西就自己尝试咯，你已经入门了。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"QGIS","slug":"QGIS","permalink":"https://tanghaojie.github.io/categories/QGIS/"},{"name":"python","slug":"QGIS/python","permalink":"https://tanghaojie.github.io/categories/QGIS/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://tanghaojie.github.io/tags/python/"},{"name":"QGIS","slug":"QGIS","permalink":"https://tanghaojie.github.io/tags/QGIS/"}],"author":null},{"title":"uniapp快速实践","slug":"fast-uniapp","date":"2020-04-09T17:29:03.000Z","updated":"2020-05-14T03:27:23.107Z","comments":true,"path":"2020/04/10/fast-uniapp/","link":"","permalink":"https://tanghaojie.github.io/2020/04/10/fast-uniapp/","excerpt":"","text":"介绍之前给文保局做了GIS系统和物联网监控系统效果不错，现在想弄个erp，问了一下业务规模，几乎约等于“零”。咋办，单一业务线走到底呗。本来说最近一直在搞flutter，就用flutter给他们弄一个，app和web（beta）一套直接就生成了。方便快速（省事）。结果呢，人家要用微信小程序…哎，甲方是爸爸。结合已有技术经验和业务规模（如果有的话{笑}），还要考虑可能出现的业务平台变更这种吊炸天需求，调研了几个平台，这里我列一下： 1.微信小程序原生：难用的ide，技术栈就是web变种。2.H5+app：原生代码少不了，Android和iOS要单独适配，涉及到兼容性的问题。3.mpvue：美团搞的，基于Vue.js的小程序开发框架，小程序和H5一套搞定型。4.uni-app：Dcloud搞的，也是基于Vue.js的框架，iOS、Android、H5、各种小程序一套搞定型。 对比了一下，微信小程序原生、H5+app，我直接就放弃了，微信小程序那个IDE简直不要太难用，而且改平台就是重写代码；H5+app一个人弄太费事不说，缺少优化可能效果也一般，虽然有原生app的超高天花板，但是谁叫咱就一个人，还要快速出活呢；mpvue本来我是准备选的，小程序+H5，基本上都能干了，后面要改原生app的话，我就套webview的壳，关键是开源免费，怪就怪在开源吧，我上github看了下commits和issues，最近的commit是八个月前了…issues也有点混乱的感觉，加上之前爆出美团的KPI事件，我觉得为了我的KPI和头发，还是算了吧。都说到这了，还有的选吗？最开始我是觉得uniapp商业话太严重（推广），加上不开源，还是有些顾虑的，但是好像现在是（部分）开源了？推广说明官方很重视，那。。还说什么呢，淦 淦因为微信小程序和uniapp都没搞过，花时间分别看了下文档，都是web变种，会web就会开发。主要是熟悉下整体的框架，为啥这样设计，有哪些个组件分别能干啥事，有哪些API。细节千万别看，太花时间，而且你肯定记不住，所以就直接上手吧。uniapp支持Weex，在app端，用vue页面的话就是用webview渲染的，用nvue的话就是用原生渲染。(｡･∀･)ﾉﾞ嗨，等于说码量还是不小啊，坑还是多啊。不过uniapp支持#ifdef #endif条件编译语法，这个没啥好说的，写后端的都知道，赞一个。然后就是写项目了，如果看了微信小程序文档和uniapp的文档，你就会发现，其实就是个web前端的东西，无非就是语法变了一点，配置文件针对多端合并重封装了，写代码的时候要注意兼容，一个ui组件把几个端都同时考虑进来，用条件编译。就行了，就是这么简单，快速实践就介绍完了（其实是不知道说啥了）。（逃） 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uniapp","slug":"uniapp","permalink":"https://tanghaojie.github.io/categories/uniapp/"}],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://tanghaojie.github.io/tags/uniapp/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://tanghaojie.github.io/tags/微信小程序/"}],"author":null},{"title":"网页插件","slug":"weatherPlugin","date":"2020-04-03T13:47:44.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/04/03/weatherPlugin/","link":"","permalink":"https://tanghaojie.github.io/2020/04/03/weatherPlugin/","excerpt":"","text":"天气中国天气网：https://cj.weather.com.cn/plugin/pc生成插件放到： themes/matery/layout/layout.ejs 动态诗词今日诗词：https://www.jinrishici.com/一言: https://hitokoto.cn/ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"plugin","slug":"plugin","permalink":"https://tanghaojie.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://tanghaojie.github.io/tags/plugin/"}],"author":null},{"title":"我的博客地址","slug":"myblogaddress","date":"2020-04-03T12:43:56.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/04/03/myblogaddress/","link":"","permalink":"https://tanghaojie.github.io/2020/04/03/myblogaddress/","excerpt":"","text":"由于众所周知的原因，单纯把博客部署到一个地方，很可能访问不到，或者访问很慢，所以这里同时部署到github和gitee，提高访问速度 [手动狗头] 前置条件：你会搭博客（网站） 示例 我的两个博客地址： http://tanghaojie.github.io/ https://jackie_tang.gitee.io/ gitee pages的一个坑 每次远程部署以后，需要手动到gitee pages服务里面去，手动点击更新按钮才能自动更新博客。（想自动更新？gitee pages pro了解一下） 从github同步方式部署 在gitee新建仓库: 注意点： 1.仓库名用gitee给你分配的个人地址名，可以到 个人中心–&gt;个人空间地址 中看到，不一定是你的用户名，比如我的地址是：Jackie_Tang，我的用户名是：JackieTang。因为我改过名。。。 2.下面选择导入已有仓库，然后填入github地址以后，仓库名会自动变成github仓库名，所以又需要你自己去上面改一次 点击 创建，等待gitee自动导入github仓库。 导入完成如图配置 注意点： 1.选择使用Https，否则会跨域 以上步骤就完成了，你的博客地址为：{个人地址名}.gitee.io，以后要同步github的数据，只需要这样操作： 同步上传 我用的hexo，在 _config.yml 文件： deploy: type: git repo: github: https://github.com/tanghaojie/tanghaojie.github.io.git gitee: https://gitee.com/Jackie_Tang/Jackie_Tang.git branch: master 加两个repo就好 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"blog","slug":"blog","permalink":"https://tanghaojie.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://tanghaojie.github.io/tags/blog/"}],"author":null},{"title":"中华人民共和国省级行政区域界线标注的小tip","slug":"provincial-boundary","date":"2020-04-01T13:45:29.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/04/01/provincial-boundary/","link":"","permalink":"https://tanghaojie.github.io/2020/04/01/provincial-boundary/","excerpt":"","text":"如果大段以河道（或其他水体）为省界的，全部以实线标注会影响河流水体的连续呈现时，则用断续线表示。如晋陕、晋豫黄河省界段，川藏、川滇（东段）长江省界段。 说明我本人没有找到这个规定的出处，是否是国家规范不做保证。但是百度地图现在看已经是这样做标注了。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/categories/gis/"}],"tags":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/tags/gis/"}],"author":null},{"title":"flutter定位插件location","slug":"flutter-location","date":"2020-03-31T12:31:11.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/03/31/flutter-location/","link":"","permalink":"https://tanghaojie.github.io/2020/03/31/flutter-location/","excerpt":"","text":"iOS没测试，Android需要用到GMS来辅助定位，所以国内不能用！不能用！！不能用！！！ 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/categories/flutter/"},{"name":"location","slug":"flutter/location","permalink":"https://tanghaojie.github.io/categories/flutter/location/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/tags/flutter/"},{"name":"location","slug":"location","permalink":"https://tanghaojie.github.io/tags/location/"},{"name":"定位","slug":"定位","permalink":"https://tanghaojie.github.io/tags/定位/"}],"author":null},{"title":"flutter加载地图的几种方式对比[测试]","slug":"flutter-load-map","date":"2020-03-31T12:14:47.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/03/31/flutter-load-map/","link":"","permalink":"https://tanghaojie.github.io/2020/03/31/flutter-load-map/","excerpt":"","text":"1.flutter_map：Leaflet用 Flutter的实现，主要用于加载瓦片地图和简单注记，复杂的几何要素可以用插件的形式，但要自己实现代码。没有自带定位的功能，要自己处理。综合来看，只用瓦片地图，定位这些基础功能的话，可以选这个，团队强大的话，复杂功能也可以自己搞插件。天花板挺高的。 2.webview_flutter：fluter官方出品的webview插件，没什么好说的，网页能干的事他都能干。最大的问题是目前还是预览版，官方说因为用了新的机制，具体什么机制我也没看，能不能实现官方没说，deadline也没说，有点不让人放心。 3.flutter_webview_plugin：网上综合推荐比较多的一个插件了，就是调用native webview，稳定性，兼容性肯定没问题。但是由于接入原生，导致webview始终在最上层，会覆盖在所有 Flutter widget之上，灵活性牺牲很大。最新的说明里写了，要把这个插件合并到上面提到的官方插件里面去了。所以基本上不用选了。 4.其他库：比如说高德amap，百度地图，这类就局限平台了。 目前就测试了这几种地图使用方式，总的来说，有团队，有时间，能自己研发的，可以上。不然的话还是用混合开发吧，flutter还需要给他些时间来成熟。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/categories/flutter/"},{"name":"map","slug":"flutter/map","permalink":"https://tanghaojie.github.io/categories/flutter/map/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/tags/flutter/"},{"name":"map","slug":"map","permalink":"https://tanghaojie.github.io/tags/map/"},{"name":"webview","slug":"webview","permalink":"https://tanghaojie.github.io/tags/webview/"}],"author":null},{"title":"Flutter Doctor：Android license status unknown","slug":"post","date":"2020-03-27T10:22:12.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/03/27/post/","link":"","permalink":"https://tanghaojie.github.io/2020/03/27/post/","excerpt":"","text":"执行： flutter doctor --android-licenses之后一路同意就好了。 如果显示： &gt; Android sdkmanager tool not found (PATH)1.打开Android SDK Manager2.选SDK Tools3.把下面的，Hide Obsolete Packages，取消勾选4.打勾Android SDK Tools (Obsolete)5.确定安装 Flutter团队知道这个问题，官方建议就是这么处理，后续版本会解决的。 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://tanghaojie.github.io/tags/flutter/"},{"name":"Android","slug":"Android","permalink":"https://tanghaojie.github.io/tags/Android/"},{"name":"iOS","slug":"iOS","permalink":"https://tanghaojie.github.io/tags/iOS/"}],"author":null},{"title":"office2016零售版转VOL版","slug":"office2016ToVol","date":"2020-03-19T11:06:57.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/03/19/office2016ToVol/","link":"","permalink":"https://tanghaojie.github.io/2020/03/19/office2016ToVol/","excerpt":"","text":"以下代码复制为：.bat文件 @ECHO OFF&PUSHD %~DP0 setlocal EnableDelayedExpansion&color 3e & cd /d \"%~dp0\" title office2016 retail转换vol版 %1 %2 mshta vbscript:createobject(\"shell.application\").shellexecute(\"%~s0\",\"goto :runas\",\"\",\"runas\",1)(window.close)&goto :eof :runas if exist \"%ProgramFiles%\\Microsoft Office\\Office16\\ospp.vbs\" cd /d \"%ProgramFiles%\\Microsoft Office\\Office16\" if exist \"%ProgramFiles(x86)%\\Microsoft Office\\Office16\\ospp.vbs\" cd /d \"%ProgramFiles(x86)%\\Microsoft Office\\Office16\" :WH cls echo. echo 选择需要转化的office版本序号 echo. echo -------------------------------------------------------------------------------- echo 1. 零售版 Office Pro Plus 2016 转化为VOL版 echo. echo 2. 零售版 Office Visio Pro 2016 转化为VOL版 echo. echo 3. 零售版 Office Project Pro 2016 转化为VOL版 echo. echo. -------------------------------------------------------------------------------- set /p tsk=\"请输入需要转化的office版本序号【回车】确认（1-3）: \" if not defined tsk goto:err if %tsk%==1 goto:1 if %tsk%==2 goto:2 if %tsk%==3 goto:3 :err goto:WH :1 cls echo 正在安装 KMS 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\proplusvl_kms*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul echo 正在安装 MAK 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\proplusvl_mak*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul set /p y=请输入激活密钥，按回车确定: cscript ospp.vbs /inpkey:%y% goto :e :2 cls echo 正在安装 KMS 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\visio???vl_kms*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul echo 正在安装 MAK 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\visio???vl_mak*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul set /p y=请输入激活密钥，按回车确定: cscript ospp.vbs /inpkey:%y% goto :e :3 cls echo 正在安装 KMS 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\project???vl_kms*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul echo 正在安装 MAK 许可证... for /f %%x in ('dir /b ..\\root\\Licenses16\\project???vl_mak*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" >nul set /p y=请输入激活密钥，按回车确定: cscript ospp.vbs /inpkey:%y% goto :e :e echo. echo 转化完成，按任意键退出！ pause >nul exit 让填写秘钥时，输入 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"other","slug":"other","permalink":"https://tanghaojie.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://tanghaojie.github.io/tags/other/"}],"author":null},{"title":"vue use video.js support flash rtmp","slug":"vueVideo","date":"2020-03-12T13:06:17.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2020/03/12/vueVideo/","link":"","permalink":"https://tanghaojie.github.io/2020/03/12/vueVideo/","excerpt":"","text":"在Vue中使用video.js，兼容flash视频，研究了一天，简单记录一下。1.包安装 npm install --save videojs npm install --save videojs-flash //如果需要用flash的话 2.实现vue-video.vue文件 &lt;template> &lt;div> &lt;video ref=\"videoPlayer\" class=\"video-js\">&lt;/video> &lt;/div> &lt;/template> &lt;script> import videojs from 'video.js' import 'videojs-flash' // if use flash import SWF_PATH from 'videojs-swf/dist/video-js.swf' // if use flash import 'video.js/dist/video-js.min.css' export default { props: { options: { type: Object, default() { return {} } } }, data() { return { player: null } }, mounted() { this.options.flash = {} // if use flash this.options.flash.swf = SWF_PATH // if use flash this.player = videojs(this.$refs.videoPlayer, this.options) }, beforeDestroy() { if (this.player) { this.player.dispose() } } } &lt;/script> 3.使用 &lt;template> &lt;div id=\"app\"> &lt;vue-video :options=\"videoOptions\" /> &lt;/div> &lt;/template> &lt;script> import vueVideo from './path/to/vue-video.vue' export default { name: 'App', components: { vueVideo }, data() { return { // videoOptions标准参考 https://docs.videojs.com/ videoOptions: { autoplay: true, controls: false, language: 'zh', width: 100, height: 200, sources: [ { src: 'rtmp://*************/live/qq', type: 'rtmp/flv' } ] // techOrder: ['flash'] } } } } &lt;/script> rtmp、mp4已测试没有问题，其他格式就没测试了。需要发布才能进行测试，类似file://C:/test.html这种文件形式的是无法使用的 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"vue","slug":"vue","permalink":"https://tanghaojie.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tanghaojie.github.io/tags/vue/"},{"name":"video.js","slug":"video-js","permalink":"https://tanghaojie.github.io/tags/video-js/"},{"name":"rtmp","slug":"rtmp","permalink":"https://tanghaojie.github.io/tags/rtmp/"}],"author":null},{"title":"Postgis和EntityFrameworkCore的关系映射，几何字段映射","slug":"entityframeworkcorewithpostgis","date":"2019-12-12T13:02:03.000Z","updated":"2020-05-14T03:27:23.097Z","comments":true,"path":"2019/12/12/entityframeworkcorewithpostgis/","link":"","permalink":"https://tanghaojie.github.io/2019/12/12/entityframeworkcorewithpostgis/","excerpt":"","text":"这篇文章主要讨论Code First模式，其他模式我不怎么用的，不敢保证 现在搞开发数据库操作基本上都用Orm了吧，但是我们搞GIS的，因为涉及到空间几何字段、空间拓扑运算操作的情况，很多时候传统的Orm就解决不了了，所以很多时候要么就直接用odbc原生Sql操作了；或者是业务部分EF+空间几何Sql这么来操作。这两个方案实现起来确实没什么问题，但前者用起来实在麻烦，很多简单的东西就搞复杂了，要么统一封装一下的话就又回到Orm的路子上；后者是最灵活的一种方案了，任何需求都可以用这个办法来解决，但问题就是整个软件的框架会显得很混乱，新人来了经常问为啥要这样搞，思维切换起来很麻烦，如果要改需求还涉及到空间几何的话，那只能打一架好了… 之前的DotnetFramework+Npgsql+EF是不支持使用PostGIS扩展的，官方一直也没明确表态后续规划什么的，直到最近在github上看到开发者说以后应该不会支持了，会把重心放到EF Core上。因此，想要直接映射几何字段几乎变成了不可能的事情。 网上有用SharpMap做映射的解决方案，但是我一直没有测试成功过官方的数据类型映射表里面也写了System.Data.Spatial.DbGeometry可以映射到Geometry类型。这个能在CodeFirst下识别，但生成的字段类型并不是Geometry，而是Byte[]，我也不知道哪错了，诶 直到最近我打算把平台切换到.NetCore，然后去研究了一下，整个人就豁然开朗了啊。1.微软官方明确表态实现几何类型的字段。2.Npgsql的Core版本确实在实现Postgis的东西，而且进度神速。那么，就用呗~ 依赖很简单，就两个包： 1.Npgsql.EntityFrameworkCore.PostgreSQL 2.Npgsql.EntityFrameworkCore.PostgreSQL.NetTopologySuite 然后是配置，首先数据库里面要启用Postgis，简单：Create Extension Postgis;EFCore框架： dbContextOptions.UseNpgsql(connectionString, o => o.UseNetTopologySuite()); //这在哪自己找一下 //这在你的DbContext里面 protected override void OnModelCreating(ModelBuilder builder) { builder.HasPostgresExtension(\"postgis\"); //启用postgis扩展，需要手动写扩展名也是有原因的哦 } 齐活了，就这么简单。使用的话就很简单了： using NetTopologySuite.Geometries; public class TestGeometry{ [Column(TypeName = \"geometry (MultiLineString)\")] //可以指定类型、维度、坐标系 public MultiLineString Geom { get; set; } } 有了这个后续的操作就简单多了： Geom.Area //面积 Geom.AsBinary() //转wkb Geom.AsText() //同ToString()，转wkt ... ... 就不一一列举了，官方文档很全面的。 * 补充一下其他的坑吧，转 .Net Core以后，Gdal会成为一个很大的问题，这个需要好好的评估一下，Gdal目前还没有官方做Core的适配，这个影响挺大的。当然Gdal的功能也有相应各个独立的库能替换的，但始终不会像Gdal这么得心应手，一定要注意评估这一点！！！ * 版权声明：除非注明，本博文章均为原创，转载请以链接形式标明本文地址。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C#","slug":"C","permalink":"https://tanghaojie.github.io/categories/C/"},{"name":"gis","slug":"C/gis","permalink":"https://tanghaojie.github.io/categories/C/gis/"}],"tags":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/tags/gis/"},{"name":"entityframework","slug":"entityframework","permalink":"https://tanghaojie.github.io/tags/entityframework/"},{"name":".net core","slug":"net-core","permalink":"https://tanghaojie.github.io/tags/net-core/"},{"name":"postgis","slug":"postgis","permalink":"https://tanghaojie.github.io/tags/postgis/"}],"author":null},{"title":"网站收录","slug":"website","date":"2019-10-12T08:22:48.000Z","updated":"2019-10-12T08:29:21.598Z","comments":true,"path":"2019/10/12/website/","link":"","permalink":"https://tanghaojie.github.io/2019/10/12/website/","excerpt":"","text":"Google探索实验室 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"website","slug":"website","permalink":"https://tanghaojie.github.io/categories/website/"}],"tags":[{"name":"website","slug":"website","permalink":"https://tanghaojie.github.io/tags/website/"}],"author":null},{"title":"地理信息相关标准","slug":"gisstandard","date":"2019-10-12T07:58:36.000Z","updated":"2019-10-12T08:22:01.342Z","comments":true,"path":"2019/10/12/gisstandard/","link":"","permalink":"https://tanghaojie.github.io/2019/10/12/gisstandard/","excerpt":"","text":"OGC 开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作。 Spatial reference 坐标系统收录、查询、上传、教育。 GDal GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库。它利用抽象数据模型来表达所支持的各种文件格式。它还有一系列命令行工具来进行数据转换和处理。OGR是GDAL项目的一个分支，功能与GDAL类似，只不过它提供对矢量数据的支持。 epsg 全球坐标系统 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/categories/gis/"},{"name":"tips","slug":"gis/tips","permalink":"https://tanghaojie.github.io/categories/gis/tips/"},{"name":"website","slug":"gis/tips/website","permalink":"https://tanghaojie.github.io/categories/gis/tips/website/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://tanghaojie.github.io/tags/tips/"},{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/tags/gis/"},{"name":"website","slug":"website","permalink":"https://tanghaojie.github.io/tags/website/"}],"author":null},{"title":"地理地图数据提供网站","slug":"gisdatawebsites","date":"2019-10-12T07:51:21.000Z","updated":"2019-10-12T08:12:45.278Z","comments":true,"path":"2019/10/12/gisdatawebsites/","link":"","permalink":"https://tanghaojie.github.io/2019/10/12/gisdatawebsites/","excerpt":"","text":"OSGeo中国 开放地理空间信息科学：技术、数据、知识共享。 spatial hadoop 一个为空间数据设计的map reduce框架，有很多超大的数据集提供下载。 全国地理信息资源目录服务 国家基础地理信息中心提供的资源查询和下载服务。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/categories/gis/"},{"name":"tips","slug":"gis/tips","permalink":"https://tanghaojie.github.io/categories/gis/tips/"},{"name":"website","slug":"gis/tips/website","permalink":"https://tanghaojie.github.io/categories/gis/tips/website/"},{"name":"data","slug":"gis/tips/website/data","permalink":"https://tanghaojie.github.io/categories/gis/tips/website/data/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://tanghaojie.github.io/tags/tips/"},{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/tags/gis/"},{"name":"website","slug":"website","permalink":"https://tanghaojie.github.io/tags/website/"},{"name":"data","slug":"data","permalink":"https://tanghaojie.github.io/tags/data/"}],"author":null},{"title":"一些好玩的地理网站","slug":"gisForFunWebsites","date":"2019-10-12T06:57:09.000Z","updated":"2019-10-12T07:55:16.022Z","comments":true,"path":"2019/10/12/gisForFunWebsites/","link":"","permalink":"https://tanghaojie.github.io/2019/10/12/gisForFunWebsites/","excerpt":"","text":"Open Street Map 人人都可编辑的世界地图，一个网上地图协作计划的产物。 Land Lines Google Creative Lab 提交的一个 Chrome Experiments 项目，基于深度学习。 GeoGuessr 这是一个真实的「情景判断游戏」。开局就是随便把玩家落在 Google 街景中的某一处，你可以在街景地图中一路游走，然后根据周遭信息，判断出身处何处。 The WebGL Globe The WebGL Globe 是一个使数据地理可视化的平台。利用这个项目提供的开源代码，我们可以制作属于自己的数据地球。在项目网站上有不少网友提交的实验，根据人口变化、火山活动、各地维基百科篇目等方方面面的数据产生不同的可视化地球。 Ghost Map Ghost Map收录了各个城市的街道路线，将其隐藏在黑暗中。通过移动鼠标，光亮像细流入川一般流淌到附近街道上，灯火明亮，车水马龙，勾勒出这座城市的建筑与街道规划。当鼠标指针停止移动，万物歇息，一切又沉入黑暗。 SNAZZY MAPS 在线Google Maps配图。自带多种风格自由选择，而且都可以自定义。 Pixel Map 在线像素地图生成。 地图慧 在线地图制作，上传自己的数据，可以做热力图、流向图等等各种专题地图。 stamen 地图与制图、数据可视化。 Map Box 在线地图制图。 Map Stack 使设计地图免费,简单,有趣。 CAD Mapper cad su 等格式的模型下载。 发现中国 中国历史地图、古地图。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/categories/gis/"},{"name":"tips","slug":"gis/tips","permalink":"https://tanghaojie.github.io/categories/gis/tips/"},{"name":"website","slug":"gis/tips/website","permalink":"https://tanghaojie.github.io/categories/gis/tips/website/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://tanghaojie.github.io/tags/tips/"},{"name":"fun","slug":"fun","permalink":"https://tanghaojie.github.io/tags/fun/"},{"name":"gis","slug":"gis","permalink":"https://tanghaojie.github.io/tags/gis/"},{"name":"website","slug":"website","permalink":"https://tanghaojie.github.io/tags/website/"}],"author":null}]}